#include <xc.h>
#define _XTAL_FREQ 20000000

#define PIR RD1
#define buzzer RB0
#define led RB1
#define RS RB3
#define RW RB4
#define EN RB5 // waire conetion

void lcd_data(unsigned char data) {
    PORTC = data;
    RS = 1; // RS is working on character mode
    RW = 0; // Write function
    EN = 1; // Enabling the LCD
    __delay_ms(100);
    EN = 0;

}

void lcd_command(unsigned char cmd) {
    PORTC = cmd;
    RS = 0; // RS is working on character mode
    RW = 0; // Write function
    EN = 1; // Enabling the LCD
    __delay_ms(100);
    EN = 0;

}

void lcd_string(unsigned char *str, unsigned char num) {
    unsigned char i;
    for (i = 0; i < num; i++) {

        lcd_data(str[i]);
    }
}

void lcd_getup() {

    lcd_command(0x38); // 2 line and 5*7 matrix
    lcd_command(0x06); // Increment cursor (shift cursor to right)
    lcd_command(0x0C); // Display on , cursor off
    lcd_command(0x01); // clear display screen
}

void main(void) {

    TRISC = 0x00; // all B port output
    TRISB0 = 0; // buzzer
    TRISB1 = 0; //led
    TRISB3 = 0; // lcd output
    TRISB4 = 0;
    TRISB5 = 0;
    TRISD1 = 0; //pir

    lcd_getup();

    while (1) {

        if (PIR == 1) {

            buzzer = 1;
            led = 1;

            lcd_command(0x83); // position 1st row 
            lcd_string("Motion",7);
            lcd_command(0xC3); // position 2nd row      
            lcd_string("Detected!",9);
            __delay_ms(100);
            lcd_command(0x01); // clear  
        }

        else{
            buzzer = 0;
            led = 0;

            lcd_command(0x83); // position 1st row 
            lcd_string("Motion",7);
            lcd_command(0xC3); // position 2nd row      
            lcd_string("NOT Detected!",13);
            __delay_ms(100);
            lcd_command(0x01); // clear  
        }

    }

    return;
}

#include <xc.h>
#include "config.h"
#include <stdint.h>
#include <stdio.h>

#define _XTAL_FREQ 2000000
#define LCD_EN_Delay 500
#define LCD_DATA_PORT_D TRISD
#define LCD_RS_D TRISD2
#define LCD_EN_D TRISD1
#define RS RD2
#define EN RD1
#define D4 RD4
#define D5 RD5
#define D6 RD6
#define D7 RD7

uint16_t AN0RES=0;
float Temperature, Voltage;
char* line1 = " Temperature Is ";
char* TempSTR[16];

void ADC_Init();
uint16_t ADC_Read(uint8_t);
void LCD_Init();
void LCD_Clear();
void LCD_CMD(char);
void LCD_DATA(char);
void LCD_Set_Cursor(char, char);
void LCD_Write_Char(char);
void LCD_Write_String(char*);

void main(void) {
    
    LCD_Init();
    LCD_Clear();
    ADC_Init();
    while(1)
    {
        // Read The ADC
        AN0RES = ADC_Read(0); // Read Analog Channel 0
        // Calculate The Temperature
        Voltage = AN0RES * 0.0048828;
        Temperature = Voltage / 0.01;
        // Convert The Temperature From Float To String
        sprintf(TempSTR, "     %.3fc", Temperature);
        // Print Out The Temperature
        LCD_Set_Cursor(1,1);
        LCD_Write_String(line1);
        LCD_Set_Cursor(2,1);
        LCD_Write_String(TempSTR);
        __delay_ms(10);
    }
    return;
}

void ADC_Init()
{
    ADCON0 = 0x41;  // Turn ADC ON, Select AN0 Channel, ADC Clock = Fosc/8
    ADCON1 = 0x80;  // All 8 Channels Are Analog, Result is "Right-Justified"
                    // ADC Clock = Fosc/8
}
uint16_t ADC_Read(uint8_t ANC)
{
    if(ANC<0 || ANC>7)    // Check Channel Number Validity
    { return 0;}
    ADCON0 &= 0x11000101; // Clear The Channel Selection Bits
    ADCON0 |= ANC<<3;     // Select The Required Channel (ANC)
                          // Wait The Aquisition Time
    __delay_us(30);       // The Minimum Tacq = 20us, So That should be enough
    GO_DONE = 1;          // Start A/D Conversion
    while(ADCON0bits.GO_DONE); // Polling GO_DONE Bit
                               // Provides Delay Until Conversion Is Complete
    return ((ADRESH << 8) + ADRESL); // Return The Right-Justified 10-Bit Result
}

void LCD_DATA(char Data)
{
    if(Data& 1) 
        D4 = 1;
    else
        D4 = 0;

    if(Data& 2)
        D5 = 1;
    else
        D5 = 0;

    if(Data& 4)
        D6 = 1;
    else
        D6 = 0;

    if(Data& 8) 
        D7 = 1;
    else
        D7 = 0;
}
void LCD_CMD(char a)
{
    RS = 0;           
    LCD_DATA(a); //Incoming Hex value
    EN  = 1;         
    __delay_ms(4);
    EN  = 0;         
}
void LCD_Clear()
{
    LCD_CMD(0); //Clear the LCD
    LCD_CMD(1); //Move the cursor to first position
}
void LCD_Set_Cursor(char a, char b)
{
    char Temp,z,y;
    if(a== 1)
    {
      Temp = 0x80 + b - 1;
        z = Temp>>4; //Lower 8-bits
        y = Temp & 0x0F; //Upper 8-bits
        LCD_CMD(z); //Set Row
        LCD_CMD(y); //Set Column
    }
    else if(a== 2)
    {
        Temp = 0xC0 + b - 1;
        z = Temp>>4; //Lower 8-bits
        y = Temp & 0x0F; //Upper 8-bits
        LCD_CMD(z); //Set Row
        LCD_CMD(y); //Set Column
    }
}
void LCD_Init()
{
  // IO Pin Configurations
  LCD_DATA_PORT_D = 0x00;
  LCD_RS_D = 0;
  LCD_EN_D = 0;
  // The Procedure As Described in Datasheet
  LCD_DATA(0x00);
  __delay_us(LCD_EN_Delay); 
  LCD_CMD(0x03);
  __delay_ms(5);
  LCD_CMD(0x03);
  __delay_ms(11);
  LCD_CMD(0x03); 
  LCD_CMD(0x02); //Clears the RAM and initializes the LCD
  LCD_CMD(0x02); //Clears the RAM and initializes the LCD
  LCD_CMD(0x08); //Select Row 1
  LCD_CMD(0x00); //Clear Row 1 Display
  LCD_CMD(0x0C); //Select Row 2
  LCD_CMD(0x00); //Clear Row 2 Display
  LCD_CMD(0x06);
}
void LCD_Write_Char(char data)
{
   char Lower_Nibble,Upper_Nibble;
   Lower_Nibble = data&0x0F;
   Upper_Nibble = data&0xF0;
   RS = 1;        
   LCD_DATA(Upper_Nibble>>4);  
   EN = 1;
   __delay_us(LCD_EN_Delay); 
   EN = 0;
   __delay_us(LCD_EN_Delay); 
   LCD_DATA(Lower_Nibble); 
   EN = 1;
   __delay_us(LCD_EN_Delay); 
   EN = 0;
   __delay_us(LCD_EN_Delay); 
}
void LCD_Write_String(char *a)
{
    int i;
    for(i=0;a[i]!='\0';i++)
       LCD_Write_Char(a[i]);
}




